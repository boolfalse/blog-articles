
## thread pool, անալոգ ռեալ կյանքից (մաս 5/7)

### NGNTJS - մաս 5

---

NGNTJS հոդվածաշարի նախորդ [մաս 4](https://medium.com/@boolfalse/libuv-event-loop-%D5%AE%D5%A1%D5%B6%D5%B8%D5%A9%D5%B8%D6%82%D5%A9%D5%B5%D5%B8%D6%82%D5%B6-886772ab3df)֊ում մենք դիտարկեցինք libUV գրադարանը, ծանոթացանք event-loop մեխանիզմի աշխատանքի հետ։
Այս մասը կլինի [libUV](https://github.com/libuv/libuv)֊ի "thread pool" կոչվող feature֊ի մասին։

<img src="https://i.imgur.com/Cuai8DB.png" style="width:100%;">

[Նկարը՝ [unsplash.com](https://unsplash.com/photos/4ftI4lCcByM)]

Thread pool֊ը նախատեսված է կատարելու JavaScript֊ի blocking operation֊ները: Ինչպես միգուցե արդեն գիտենք՝ JavaScript execution֊ի համար (որպես runtime՝ նաև Node.js֊ում) նախատեսված է մեկ thread, և այդ thread֊ում ժամանակի տվյալ պահին կատարվում է մի գործողություն։ Երբ կոդի execution֊ի ժամանակ հանդիպում են  blocking operation֊ներ, ինչպիսիք են հետևյալ մեթոդները

- [fs](https://nodejs.org/api/fs.html) (fs.createReadStream(), fs.chown(), fs.copyFile())
- [crypto](https://nodejs.org/api/crypto.html) (crypto.scrypt(), crypto.sign(), crypto.verify())
- [dns](https://nodejs.org/api/dns.html) (dns.lookup(), dns.resolveCname() )

կամ շատ այլ ասինխրոն մեթոդներ, ապա միակ thread֊ի աշխատանքը չծանրաբեռնելու համար "բացվում են" հավելյալ thread֊եր։ Իրականում ամեն մի thread֊ի pooling֊ը ու օգտագործումը բավականին ռեսուրս ծախսող է, և սա կատարվում է այն դեպքերում, երբ "այլ տարբերակ չկա" master thread֊ի աշխատանքը block չանելու համար։

<img src="https://i.imgur.com/VGrWoh5.png" style="width:100%;">
 
[Manufacturing single lane]

master thread֊ից thread pool֊ի գործողությունը ավելի լավ պատկերացնելու համար փորձենք կիրառել նմանատիպ անալոգ ռեալ կյանքից․

Դիտարկենք գործարանի ավագ աշխատակից, ով հետևում է գծով անցնող փաթեթավորված ապրանքների շարժին, ու նա պատասխանատու է փաթեթավորված ապրանքների վրա քաշերի պիտակների համար։ Աշխատանքի ընթացում լինում են դեպքեր, երբ փաթեթավորված ապրանքը բավական ծանր է լինում և այդ ավագ աշխատակիցը ի վիճակի չէ կշռել այն։ Այս դեպքերի համար նա ունի հատկացված կրտսեր օգնականներ, ովքեր կարող են վերցնել այդ ծանր փաթեթը, կշռել այն մեծ կշեռքի վրա, ասել ավագ աշխատակցին քաշը՝ որպեսզի նա պիտակավորի փաթեթը և տեղադրել գծի անցած ապրանքների մասում։ Անկախ քաշից՝ ամեն ծանր ապրանքը կշռելու համար պատասխանատու է 1 կրտսեր աշխատակից։ Կրտսեր աշխատակիցները երիտասարդ օգնականներ են, ովքեր պարապ չեն, այլ աշխատում են գործարանի տարբեր ենթամասերում և ցանկացած հարցման պահին պատրաստ են օգնել տվյալ հարցերի դեպքում։
Ավագ աշխատակիցը պատասխանատու է պիտակավորման համար, նա հետևում է գծին՝ ծանր ապրանքների դեպքում դիմում է օգնականներին, իսկ թեթև ապրանքները կշռում է ինքնուրույն։ Ավագ աշխատակիցը հիմնականում փորձում է չդիմել օգնակնների լրացուցիչ օգնությանը, քանի որ օգնական աշխատակիցները ևս կատարում են ինչ֊որ գործեր գործարանի տարբեր հատվածներում, թերևս հետևելով ավագ աշխատակցին՝ անհրաժեշտության դեպքում շտապ օգնության հասնելու նրան։ Այնուամենայնիվ ըստ հաստիքի՝ ավագ աշխատակիցն իրեն կցված ունի 4 օգնական, որոնք կգան օգնության։ Իհարկե ավագը դիմում է նրանց ըստ անհրաժեշտության, և հնարավորինս քիչ քանակով։
Այսպիսով, ըստ աշխատանքային կանոնադրության, աշխատանքի ընթացում գրանցվող հետևյալ դեպքերի համար կկիրառվի համապատասխան գործողություն․

- Ընդամենը 1 ծանր բեռի համար ավագը դիմում է 1 կրտսերի
- Իրար հետևից եկող 2 ծանր բեռի համար ավագը դիմում է 2 կրտսերի միաժամանակ
- Իրար հետևից եկող 3 ծանր բեռի համար ավագը դիմում է 3 կրտսերի միաժամանակ
- Իրար հետևից եկող 4 ծանր բեռի համար ավագը դիմում է 4 կրտսերի միաժամանակ
- Իրար հետևից եկող 4֊ից ավել բեռերի համար ավագը չի կարող դիմել այլ օգնականի։ Ստացվում է՝ այսպիսի դեպքերում 4 օգնականները համապատասխանաբար վերցնում են իրենց բեռերը կշռելու հերթականորեն, և նրանցից ով ավելի շուտ է ավարտում կշռելը ու ասում քաշը ավագին, նա շարունակում է վերցնել հերթական ծանր բեռը՝ չսպասելով մյուսներին։ Եվ արդեն ինչ֊որ պահի երբ նրանցից մեկը ազատվում է և տեսնում է որ էլ ծանր բեռ չի մնացել, նա չսպասելով մյուս օգնականներին, անմիջապես հեռանում է իր գործերով։

Լինում են դեպքեր, երբ ծանրաբեռնվածությունը շատանում է, և ավագ աշխատակցին անհրաժեշտ է լինում օգտվել հավելյալ կրտսեր աշխատակիցների օգնությունից։ Նման դեպքերում գործարանի տնօրենի համար հնարավորություն կա փոփոխելու կանոնակարգը, և թույլատրել ավագ աշխատակցին միաժամանակ դիմելու 4֊ից ավելի աշխատակիցների (իհարկե նաև կարող է քչացնել այն):

Այս երևակայական օրինակը ռեալ կյանքից միտված էր անելու համեմատություն հետևյալ տերմինների միջև․

- **master thread** - ավագ աշխատակից
- **thread** - ամեն մի (օգնական) աշխատակիցը
- **thread pool** - դիմում օգնական աշխատակիցներին
- **UV_THREADPOOL_SIZE** = 4 - օգնական աշխատակիցների by default քանակը (սա նաև կախված է OS֊ից)
- **Node.js runtime** - գործարանի տնօրեն
- **sync / async non-blocking operations** - բեռեր, որոնք կարող է անցակացնել ավագ աշխատակիցը
- **async & blocking CPU-intensive operations** - բեռեր, որոնք ավագ աշխատակիցը հանձնարարում է օգնական աշխատակիցներին՝ կատարելու և զեկուցելու արդյունքը

UV_THREADPOOL_SIZE֊ը մեծացնելուց՝ կհասնի պահ, երբ դա այլևս ազդեցություն չի ունենա։ Դրա համար պետք է իմանալ համակարգչում  thread֊երի մասին։

Ժամանակակից համակարգիչների կենտրոնոկան պրոցեսորների (CPU) և միջուկների (core) թիվը կարող է տարբեր լինել՝ կախված ֆիզիկական կառուցվածքից, բայց սովորաբար դրանք ունեն մեկ CPU, մինչդեռ որոշ սերվերներ, ինչպես նաև HPC (high-performance computing)  համակարգեր կարող են ունենալ մի քանի պրոցեսոր:
Մեկ CPU֊ի core֊երի քանակը նույնպես կարող է շատ տարբեր լինել 2 / 4 / 8 / 10 / 12 / 16 / 18 / 36 և ավել, սակայն ժամանակակից պրոցեսորները սովորաբար ունեն 2 (dual-core) կամ 4 (quad-core) core:
Ժամանակակից CPU֊ները հաճախ օգտագործում են տեխնոլոգիա, որը կոչվում է hyper-threading, որը թույլ է տալիս յուրաքանչյուր CPU core֊ին միաժամանակ տրամադրել մի քանի thread֊եր, սովորաբար դրանց մաքսիմալ քանակը 2 է (որոշ դեպքերում` 4)։

<img src="https://i.imgur.com/ElvOPsN.png" style="width:100%;">
 
[[Concurrency and Multithreading](https://www.logicbig.com/quick-info/programming/multi-threading.html)]

Այժմ ունենալով մի փոքր պատկերացում CPU-core-thread փոխկապակցվածության մասին, կարող ենք շարունակել thread pool մեխանիզմի մասին նկարագրությունը։

Դիտարկենք դասկան դեպք` ժամանակակից համակարգչում Node.js֊ի աշխատանքը, որտեղ կա thread pooling֊ի անհրաժեշտություն։ Այն կրիտիկական դեպքում, երբ Node.js֊ը պետք է կատարի բազմաթիվ CPU-intensive operation֊ներ, որոնց քանակը մեծ է, կատարվում է core֊երի կողմից մաքսիմալ thread֊երի տրամադրում այդ operation֊ները կատարելու համար։ Ստացվում է՝ որ quad-core CPU֊ում կունենանք 8 thread, և thread pool մեխանիզմը տեսականորեն կարող է կիրառել մաքսմիմում այդ 8 thread֊երը (այդ դեպքում տեղի կունենա CPU ամբողջական ռեսուրսների օգտագործում):
Խորհուրդ է տրվում UV_THREADPOOL_SIZE֊ը ունենալ ավելի քիչ քան տվյալ CPU֊ում հնարավորինս տրամադրվող thread֊երի քանակն է, սակայն իդեալական դեպքն այն է, երբ 4 core֊ով (մաքսիմալ 8 thread֊ի հնարավորությամբ) CPU֊ի համար ունենանք UV_THREADPOOL_SIZE֊ը հենց 4, այսինքն հենց core֊երի քանակով, որպեսզի խուսափենք OS-ի աշխատանքի ծանրաբեռնվածությունից։

Նշենք նաև, որ thread pool կատարվում է ոչ բոլոր ասինխրոն operation֊ների դեպքում։
Օրինակ՝ https.request()-ը ցանցային (Network I/O) մուտք/ելք գործողություն է, այլ ոչ պրոցեսորից հավելյալ ռեսուրս պահանջող (CPU-intensive) գործողություն, և այն չի օգտագործում thread pool:
Thread pool անելու փոխարեն, libUV-ն տվյալ task֊ը փորձում է լուծել անմիջական OS kernel֊ի միջոցով՝ օգտագործելով Network Card֊ը (այնուամենայնիվ սա նույպես ունի իր սահմանափակումները):
Փաստորեն՝ Node.js-ում async մեթոդները մշակվում են libUV-ի կողմից, բայց դրանք մշակվում են երկու տարբեր եղանակներով՝ կամ native async մեխանիզմով (օրինակ՝ [https.request()](https://nodejs.org/api/https.html#httpsrequestoptions-callback)֊ը), կամ thread pool֊ի միջոցով ([fs.createReadStream()](https://nodejs.org/api/fs.html#filehandlecreatereadstreamoptions)):
Համենայն դեպս հնարավորության դեպքում libUV-ն փորձում է խուսափել thread pool֊ի կիրառումից՝ խնայելով միջավայրում ռեսուրսները, իսկ կրիտիկական դեպքերում այն օգտագործում է հավելյան thread-եր՝ հավատարիմ մնալով իր գործառույթին, այն է՝ պահպանել non-blocking (async) աշխատանք։

Ինչպես նշեցինք՝ JavaScript execution֊ի համար նախատեսված է մեկ thread (single-threaded)։ Բայց սա ասելիս պետք է հաշվի առնել, որ խոսքը գնում է browser֊ում աշխատող JavaScript engine֊ի մասին։ Իհարկե սա վերաբերում է նաև Node.js֊ին, բայց արժի իմանալ նաև որ browser֊ից դուրս կարող են գոյություն ունենալ նաև multithread runtime environment֊ներ՝ ինչպիսին էր Microsoft֊ի [Napa.js](https://github.com/microsoft/napajs)֊ը, որի վրա աշխատանքը դադարել է 2018֊ին։ Սրա մասին կմանրամասնենք հոդվածաշարի [մաս 7](https://medium.com/@boolfalse/javascript-%D5%AC%D5%A5%D5%A6%D5%B8%D6%82-runtime-engine-%D5%B4%D5%AB%D5%BB%D5%A1%D5%BE%D5%A1%D5%B5%D6%80-node-js-%D5%B4%D6%80%D6%81%D5%A1%D5%AF%D5%AB%D6%81%D5%B6%D5%A5%D6%80-deno-bun-82cf3222e94b)֊ում։

NGNTJS հոդվածների շարքի այս մասում ծանոթացանք thread pool գաղափարի հետ, և դրա գործնական օրինակը պրոյեկտեցինք ռեալ կյանքից վերցված դեպքի վրա։
Հաջորդ՝ [մաս 6](https://medium.com/@boolfalse/event-loop-%D5%A8-%D5%BA%D6%80%D5%A1%D5%AF%D5%BF%D5%AB%D5%AF-%D6%85%D6%80%D5%AB%D5%B6%D5%A1%D5%AF%D5%B6%D5%A5%D6%80%D5%B8%D5%BE-%D5%A8%D5%B6%D5%A4%D5%B0%D5%A1%D5%B6%D5%B8%D6%82%D6%80-%D5%BA%D5%A1%D5%BF%D5%AF%D5%A5%D6%80-363eff47b6c9)֊ում կուսումնասիրենք event-loop մեխանիզմը գործնական օրինակների միջոցով, կլինի ծանոթություն Reactor Pattern֊ի աշխատանքի հետ։

***

Եթե հավանեցիք այս նյութը, ազատ կարող եք հետևել ինձ այստեղ։ 😇

Ժամանակակից տարբեր տեխնոլոգիաներով աշխատող պրոյեկտներ ուսումնասիրելու համար կարող եք հետևել իմ [GitHub](https://github.com/boolfalse) էջին, որտեղ ես ակտիվորեն հանրայնացնում եմ իմ կատարած աշխատանքի զգալի մասը։

Այլ ինֆոի համար կարող եք այցելել իմ օֆիցիալ կայք` [https://boolfalse.com/](https://boolfalse.com/)
